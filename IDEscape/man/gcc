
Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. These instructions can incur a performance penalty on Power6 processors in certain situations, such as when stepping through large arrays that cross a 16M boundary. This option is enabled by default when targetting Power6 and disabled otherwise.
-mfused-madd
-mno-fused-madd
Generate code that uses (does not use) the floating point multiply and accumulate instructions. These instructions are generated by default if hardware floating is used.
-mmulhw
-mno-mulhw
Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440 and 464 processors. These instructions are generated by default when targetting those processors.
-mdlmzb
-mno-dlmzb
Generate code that uses (does not use) the string-search dlmzb instruction on the IBM 405, 440 and 464 processors. This instruction is generated by default when targetting those processors.
-mno-bit-align
-mbit-align
On System V.4 and embedded PowerPC systems do not (do) force structures and unions that contain bit-fields to be aligned to the base type of the bit-field.
For example, by default a structure containing nothing but 8 "unsigned" bit-fields of length 1 would be aligned to a 4 byte boundary and have a size of 4 bytes. By using -mno-bit-align, the structure would be aligned to a 1 byte boundary and be one byte in size.

-mno-strict-align
-mstrict-align
On System V.4 and embedded PowerPC systems do not (do) assume that unaligned memory references will be handled by the system.
-mrelocatable
-mno-relocatable
On embedded PowerPC systems generate code that allows (does not allow) the program to be relocated to a different address at runtime. If you use -mrelocatable on any module, all objects linked together must be compiled with -mrelocatable or -mrelocatable-lib.
-mrelocatable-lib
-mno-relocatable-lib
On embedded PowerPC systems generate code that allows (does not allow) the program to be relocated to a different address at runtime. Modules compiled with -mrelocatable-lib can be linked with either modules compiled without -mrelocatable and -mrelocatable-lib or with modules compiled with the -mrelocatable options.
-mno-toc
-mtoc
On System V.4 and embedded PowerPC systems do not (do) assume that register 2 contains a pointer to a global area pointing to the addresses used in the program.
-mlittle
-mlittle-endian
On System V.4 and embedded PowerPC systems compile code for the processor in little endian mode. The -mlittle-endian option is the same as -mlittle.
-mbig
-mbig-endian
On System V.4 and embedded PowerPC systems compile code for the processor in big endian mode. The -mbig-endian option is the same as -mbig.
-mdynamic-no-pic
On Darwin and Mac OS X systems, compile code so that it is not relocatable, but that its external references are relocatable. The resulting code is suitable for applications, but not shared libraries.
-mprioritize-restricted-insns=priority
This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument priority takes the value 0/1/2 to assign no/highest/second-highest priority to dispatch slot restricted instructions.
-msched-costly-dep=dependence_type
This option controls which dependences are considered costly by the target during instruction scheduling. The argument dependence_type takes one of the following values: no: no dependence is costly, all: all dependences are costly, true_store_to_load: a true dependence from store to load is costly, store_to_load: any dependence from store to load is costly, number: any dependence which latency >= number is costly.
-minsert-sched-nops=scheme
This option controls which nop insertion scheme will be used during the second scheduling pass. The argument scheme takes one of the following values: no: Don't insert nops. pad: Pad with nops any dispatch group which has vacant issue slots, according to the scheduler's grouping. regroup_exact: Insert nops to force costly dependent insns into separate groups. Insert exactly as many nops as needed to force an insn to a new group, according to the estimated processor grouping. number: Insert nops to force costly dependent insns into separate groups. Insert number nops to force an insn to a new group.
-mcall-sysv
On System V.4 and embedded PowerPC systems compile code using calling conventions that adheres to the March 1995 draft of the System V Application Binary Interface, PowerPC processor supplement. This is the default unless you configured GCC using powerpc-*-eabiaix.
-mcall-sysv-eabi
Specify both -mcall-sysv and -meabi options.
-mcall-sysv-noeabi
Specify both -mcall-sysv and -mno-eabi options.
-mcall-solaris
On System V.4 and embedded PowerPC systems compile code for the Solaris operating system.
-mcall-linux
On System V.4 and embedded PowerPC systems compile code for the Linux-based GNU system.
-mcall-gnu
On System V.4 and embedded PowerPC systems compile code for the Hurd-based GNU system.
-mcall-netbsd
On System V.4 and embedded PowerPC systems compile code for the NetBSD operating system.
-maix-struct-return
Return all structures in memory (as specified by the AIX ABI ).
-msvr4-struct-return
Return structures smaller than 8 bytes in registers (as specified by the SVR4 ABI ).
-mabi=abi-type
Extend the current ABI with a particular extension, or remove such extension. Valid values are altivec, no-altivec, spe, no-spe, ibmlongdouble, ieeelongdouble.
-mabi=spe
Extend the current ABI with SPE ABI extensions. This does not change the default ABI , instead it adds the SPE ABI extensions to the current ABI .
-mabi=no-spe
Disable Booke SPE ABI extensions for the current ABI .
-mabi=ibmlongdouble
Change the current ABI to use IBM extended precision long double. This is a PowerPC 32-bit SYSV ABI option.
-mabi=ieeelongdouble
Change the current ABI to use IEEE extended precision long double. This is a PowerPC 32-bit Linux ABI option.
-mprototype
-mno-prototype
On System V.4 and embedded PowerPC systems assume that all calls to variable argument functions are properly prototyped. Otherwise, the compiler must insert an instruction before every non prototyped call to set or clear bit 6 of the condition code register ( CR ) to indicate whether floating point values were passed in the floating point registers in case the function takes a variable arguments. With -mprototype, only calls to prototyped variable argument functions will set or clear the bit.
-msim
On embedded PowerPC systems, assume that the startup module is called sim-crt0.o and that the standard C libraries are libsim.a and libc.a. This is the default for powerpc-*-eabisim configurations.
-mmvme
On embedded PowerPC systems, assume that the startup module is called crt0.o and the standard C libraries are libmvme.a and libc.a.
-mads
On embedded PowerPC systems, assume that the startup module is called crt0.o and the standard C libraries are libads.a and libc.a.
-myellowknife
On embedded PowerPC systems, assume that the startup module is called crt0.o and the standard C libraries are libyk.a and libc.a.
-mvxworks
On System V.4 and embedded PowerPC systems, specify that you are compiling for a VxWorks system.
-memb
On embedded PowerPC systems, set the PPC_EMB bit in the ELF flags header to indicate that eabi extended relocations are used.
-meabi
-mno-eabi
On System V.4 and embedded PowerPC systems do (do not) adhere to the Embedded Applications Binary Interface (eabi) which is a set of modifications to the System V.4 specifications. Selecting -meabi means that the stack is aligned to an 8 byte boundary, a function "__eabi" is called to from "main" to set up the eabi environment, and the -msdata option can use both "r2" and "r13" to point to two separate small data areas. Selecting -mno-eabi means that the stack is aligned to a 16 byte boundary, do not call an initialization function from "main", and the -msdata option will only use "r13" to point to a single small data area. The -meabi option is on by default if you configured GCC using one of the powerpc*-*-eabi* options.
-msdata=eabi
On System V.4 and embedded PowerPC systems, put small initialized "const" global and static data in the .sdata2 section, which is pointed to by register "r2". Put small initialized non-"const" global and static data in the .sdata section, which is pointed to by register "r13". Put small uninitialized global and static data in the .sbss section, which is adjacent to the .sdata section. The -msdata=eabi option is incompatible with the -mrelocatable option. The -msdata=eabi option also sets the -memb option.
-msdata=sysv
On System V.4 and embedded PowerPC systems, put small global and static data in the .sdata section, which is pointed to by register "r13". Put small uninitialized global and static data in the .sbss section, which is adjacent to the .sdata section. The -msdata=sysv option is incompatible with the -mrelocatable option.
-msdata=default
-msdata
On System V.4 and embedded PowerPC systems, if -meabi is used, compile code the same as -msdata=eabi, otherwise compile code the same as -msdata=sysv.
-msdata=data
On System V.4 and embedded PowerPC systems, put small global data in the .sdata section. Put small uninitialized global data in the .sbss section. Do not use register "r13" to address small data however. This is the default behavior unless other -msdata options are used.
-msdata=none
-mno-sdata
On embedded PowerPC systems, put all initialized global and static data in the .data section, and all uninitialized data in the .bss section.
-G num
On embedded PowerPC systems, put global and static items less than or equal to num bytes into the small data or bss sections instead of the normal data or bss section. By default, num is 8. The -G num switch is also passed to the linker. All modules should be compiled with the same -G num value.
-mregnames
-mno-regnames
On System V.4 and embedded PowerPC systems do (do not) emit register names in the assembly language output using symbolic forms.
-mlongcall
-mno-longcall
By default assume that all calls are far away so that a longer more expensive calling sequence is required. This is required for calls further than 32 megabytes (33,554,432 bytes) from the current location. A short call will be generated if the compiler knows the call cannot be that far away. This setting can be overridden by the "shortcall" function attribute, or by "#pragma longcall(0)".
Some linkers are capable of detecting out-of-range calls and generating glue code on the fly. On these systems, long calls are unnecessary and generate slower code. As of this writing, the AIX linker can do this, as can the GNU linker for PowerPC/64. It is planned to add this feature to the GNU linker for 32-bit PowerPC systems as well.

On Darwin/PPC systems, "#pragma longcall" will generate "jbsr callee, L42", plus a "branch island" (glue code). The two target addresses represent the callee and the "branch island". The Darwin/PPC linker will prefer the first address and generate a "bl callee" if the PPC "bl" instruction will reach the callee directly; otherwise, the linker will generate "bl L42" to call the "branch island". The "branch island" is appended to the body of the calling function; it computes the full 32-bit address of the callee and jumps to it.

On Mach-O (Darwin) systems, this option directs the compiler emit to the glue for every direct call, and the Darwin linker decides whether to use or discard it.

In the future, we may cause GCC to ignore all longcall specifications when the linker is known to generate glue.

-pthread
Adds support for multithreading with the pthreads library. This option sets flags for both the preprocessor and linker.
S/390 and zSeries Options

These are the -m options defined for the S/390 and zSeries architecture.
-mhard-float
-msoft-float
Use (do not use) the hardware floating-point instructions and registers for floating-point operations. When -msoft-float is specified, functions in libgcc.a will be used to perform floating-point operations. When -mhard-float is specified, the compiler generates IEEE floating-point instructions. This is the default.
-mhard-dfp
-mno-hard-dfp
Use (do not use) the hardware decimal-floating-point instructions for decimal-floating-point operations. When -mno-hard-dfp is specified, functions in libgcc.a will be used to perform decimal-floating-point operations. When -mhard-dfp is specified, the compiler generates decimal-floating-point hardware instructions. This is the default for -march=z9-ec or higher.
-mlong-double-64
-mlong-double-128
These switches control the size of "long double" type. A size of 64bit makes the "long double" type equivalent to the "double" type. This is the default.
-mbackchain
-mno-backchain
Store (do not store) the address of the caller's frame as backchain pointer into the callee's stack frame. A backchain may be needed to allow debugging using tools that do not understand DWARF-2 call frame information. When -mno-packed-stack is in effect, the backchain pointer is stored at the bottom of the stack frame; when -mpacked-stack is in effect, the backchain is placed into the topmost word of the 96/160 byte register save area.
In general, code compiled with -mbackchain is call-compatible with code compiled with -mmo-backchain; however, use of the backchain for debugging purposes usually requires that the whole binary is built with -mbackchain. Note that the combination of -mbackchain, -mpacked-stack and -mhard-float is not supported. In order to build a linux kernel use -msoft-float.

The default is to not maintain the backchain.

-mpacked-stack
-mno-packed-stack
Use (do not use) the packed stack layout. When -mno-packed-stack is specified, the compiler uses the all fields of the 96/160 byte register save area only for their default purpose; unused fields still take up stack space. When -mpacked-stack is specified, register save slots are densely packed at the top of the register save area; unused space is reused for other purposes, allowing for more efficient use of the available stack space. However, when -mbackchain is also in effect, the topmost word of the save area is always used to store the backchain, and the return address register is always saved two words below the backchain.
As long as the stack frame backchain is not used, code generated with -mpacked-stack is call-compatible with code generated with -mno-packed-stack. Note that some non-FSF releases of GCC 2.95 for S/390 or zSeries generated code that uses the stack frame backchain at run time, not just for debugging purposes. Such code is not call-compatible with code compiled with -mpacked-stack. Also, note that the combination of -mbackchain, -mpacked-stack and -mhard-float is not supported. In order to build a linux kernel use -msoft-float.

The default is to not use the packed stack layout.

-msmall-exec
-mno-small-exec
Generate (or do not generate) code using the "bras" instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the "basr" instruction instead, which does not have this limitation.
-m64
-m31
When -m31 is specified, generate code compliant to the GNU/Linux for S/390 ABI . When -m64 is specified, generate code compliant to the GNU/Linux for zSeries ABI . This allows GCC in particular to generate 64-bit instructions. For the s390 targets, the default is -m31, while the s390x targets default to -m64.
-mzarch
-mesa
When -mzarch is specified, generate code using the instructions available on z/Architecture. When -mesa is specified, generate code using the instructions available on ESA/390 . Note that -mesa is not possible with -m64. When generating code compliant to the GNU/Linux for S/390 ABI , the default is -mesa. When generating code compliant to the GNU/Linux for zSeries ABI , the default is -mzarch.
-mmvcle
-mno-mvcle
Generate (or do not generate) code using the "mvcle" instruction to perform block moves. When -mno-mvcle is specified, use a "mvc" loop instead. This is the default unless optimizing for size.
-mdebug
-mno-debug
Print (or do not print) additional debug information when compiling. The default is to not print debug information.
-march=cpu-type
Generate code that will run on cpu-type, which is the name of a system representing a certain processor type. Possible values for cpu-type are g5, g6, z900, z990, z9-109, z9-ec and z10. When generating code using the instructions available on z/Architecture, the default is -march=z900. Otherwise, the default is -march=g5.
-mtune=cpu-type
Tune to cpu-type everything applicable about the generated code, except for the ABI and the set of available instructions. The list of cpu-type values is the same as for -march. The default is the value used for -march.
-mtpf-trace
-mno-tpf-trace
Generate code that adds (does not add) in TPF OS specific branches to trace routines in the operating system. This option is off by default, even when compiling for the TPF OS .
-mfused-madd
-mno-fused-madd
Generate code that uses (does not use) the floating point multiply and accumulate instructions. These instructions are generated by default if hardware floating point is used.
-mwarn-framesize=framesize
Emit a warning if the current function exceeds the given frame size. Because this is a compile time check it doesn't need to be a real problem when the program runs. It is intended to identify functions which most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.
-mwarn-dynamicstack
Emit a warning if the function calls alloca or uses dynamically sized arrays. This is generally a bad idea with a limited stack size.
-mstack-guard=stack-guard
-mstack-size=stack-size
If these options are provided the s390 back end emits additional instructions in the function prologue which trigger a trap if the stack size is stack-guard bytes above the stack-size (remember that the stack on s390 grows downward). If the stack-guard option is omitted the smallest power of 2 larger than the frame size of the compiled function is chosen. These options are intended to be used to help debugging stack overflow problems. The additionally emitted code causes only little overhead and hence can also be used in production like systems without greater performance degradation. The given values have to be exact powers of 2 and stack-size has to be greater than stack-guard without exceeding 64k. In order to be efficient the extra code makes the assumption that the stack starts at an address aligned to the value given by stack-size. The stack-guard option can only be used in conjunction with stack-size.
Score Options

These options are defined for Score implementations:
-meb
Compile code for big endian mode. This is the default.
-mel
Compile code for little endian mode.
-mnhwloop
Disable generate bcnz instruction.
-muls
Enable generate unaligned load and store instruction.
-mmac
Enable the use of multiply-accumulate instructions. Disabled by default.
-mscore5
Specify the SCORE5 as the target architecture.
-mscore5u
Specify the SCORE5U of the target architecture.
-mscore7
Specify the SCORE7 as the target architecture. This is the default.
-mscore7d
Specify the SCORE7D as the target architecture.
SH Options

These -m options are defined for the SH implementations:
-m1
Generate code for the SH1 .

-m2

Generate code for the SH2 .

-m2e
Generate code for the SH2e.
-m3
Generate code for the SH3 .

-m3e
Generate code for the SH3e.
-m4-nofpu
Generate code for the SH4 without a floating-point unit.
-m4-single-only
Generate code for the SH4 with a floating-point unit that only supports single-precision arithmetic.
-m4-single
Generate code for the SH4 assuming the floating-point unit is in single-precision mode by default.
-m4
Generate code for the SH4 .

-m4a-nofpu
Generate code for the SH4al-dsp, or for a SH4a in such a way that the floating-point unit is not used.
-m4a-single-only
Generate code for the SH4a, in such a way that no double-precision floating point operations are used.
-m4a-single
Generate code for the SH4a assuming the floating-point unit is in single-precision mode by default.
-m4a
Generate code for the SH4a.
-m4al
Same as -m4a-nofpu, except that it implicitly passes -dsp to the assembler. GCC doesn't generate any DSP instructions at the moment.
-mb
Compile code for the processor in big endian mode.

-ml

Compile code for the processor in little endian mode.

-mdalign
Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library will not work unless you recompile it first with -mdalign.
-mrelax
Shorten some address references at link time, when possible; uses the linker option -relax.
-mbigtable
Use 32-bit offsets in "switch" tables. The default is to use 16-bit offsets.
-mbitops
Enable the use of bit manipulation instructions on SH2A .
-mfmovd
Enable the use of the instruction "fmovd".
-mhitachi
Comply with the calling conventions defined by Renesas.
-mrenesas
Comply with the calling conventions defined by Renesas.
-mno-renesas
Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain except for sh-symbianelf.
-mnomacsave
Mark the "MAC" register as call-clobbered, even if -mhitachi is given.
-mieee
Increase IEEE-compliance of floating-point code. At the moment, this is equivalent to -fno-finite-math-only. When generating 16 bit SH opcodes, getting IEEE-conforming results for comparisons of NANs / infinities incurs extra overhead in every floating point comparison, therefore the default is set to -ffinite-math-only.
-minline-ic_invalidate
Inline code to invalidate instruction cache entries after setting up nested function trampolines. This option has no effect if -musermode is in effect and the selected code generation option (e.g. -m4) does not allow the use of the icbi instruction. If the selected code generation option does not allow the use of the icbi instruction, and -musermode is not in effect, the inlined code will manipulate the instruction cache address array directly with an associative write. This not only requires privileged mode, but it will also fail if the cache line had been mapped via the TLB and has become unmapped.
-misize
Dump instruction size and location in the assembly code.
-mpadstruct
This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI .
-mspace
Optimize for space instead of speed. Implied by -Os.
-mprefergot
When generating position-independent code, emit function calls using the Global Offset Table instead of the Procedure Linkage Table.
-musermode
Don't generate privileged mode only code; implies -mno-inline-ic_invalidate if the inlined code would not work in user mode. This is the default when the target is "sh-*-linux*".
-multcost=number
Set the cost to assume for a multiply insn.
-mdiv=strategy
Set the division strategy to use for SHmedia code. strategy must be one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp . "fp" performs the operation in floating point. This has a very high latency, but needs only a few instructions, so it might be a good choice if your code has enough easily exploitable ILP to allow the compiler to schedule the floating point instructions together with other instructions. Division by zero causes a floating point exception. "inv" uses integer operations to calculate the inverse of the divisor, and then multiplies the dividend with the inverse. This strategy allows cse and hoisting of the inverse calculation. Division by zero calculates an unspecified result, but does not trap. "inv:minlat" is a variant of "inv" where if no cse / hoisting opportunities have been found, or if the entire operation has been hoisted to the same place, the last stages of the inverse calculation are intertwined with the final multiply to reduce the overall latency, at the expense of using a few more instructions, and thus offering fewer scheduling opportunities with other code. "call" calls a library function that usually implements the inv:minlat strategy. This gives high code density for m5-*media-nofpu compilations. "call2" uses a different entry point of the same library function, where it assumes that a pointer to a lookup table has already been set up, which exposes the pointer load to cse / code hoisting optimizations. "inv:call", "inv:call2" and "inv:fp" all use the "inv" algorithm for initial code generation, but if the code stays unoptimized, revert to the "call", "call2", or "fp" strategies, respectively. Note that the potentially-trapping side effect of division by zero is carried by a separate instruction, so it is possible that all the integer instructions are hoisted out, but the marker for the side effect stays where it is. A recombination to fp operations or a call is not possible in that case. "inv20u" and "inv20l" are variants of the "inv:minlat" strategy. In the case that the inverse calculation was nor separated from the multiply, they speed up division where the dividend fits into 20 bits (plus sign where applicable), by inserting a test to skip a number of operations in this case; this test slows down the case of larger dividends. inv20u assumes the case of a such a small dividend to be unlikely, and inv20l assumes it to be likely.
-mdivsi3_libfunc=name
Set the name of the library function used for 32 bit signed division to name. This only affect the name used in the call and inv:call division strategies, and the compiler will still expect the same sets of input/output/clobbered registers as if this option was not present.
-mfixed-range=register-range
Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator can not use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.
-madjust-unroll
Throttle unrolling to avoid thrashing target registers. This option only has an effect if the gcc code base supports the TARGET_ADJUST_UNROLL_MAX target hook.
-mindexed-addressing
Enable the use of the indexed addressing mode for SHmedia32/SHcompact. This is only safe if the hardware and/or OS implement 32 bit wrap-around semantics for the indexed addressing mode. The architecture allows the implementation of processors with 64 bit MMU , which the OS could use to get 32 bit addressing, but since no current hardware implementation supports this or any other way to make the indexed addressing mode safe to use in the 32 bit ABI , the default is -mno-indexed-addressing.
-mgettrcost=number
Set the cost assumed for the gettr instruction to number. The default is 2 if -mpt-fixed is in effect, 100 otherwise.
-mpt-fixed
Assume pt* instructions won't trap. This will generally generate better scheduled code, but is unsafe on current hardware. The current architecture definition says that ptabs and ptrel trap when the target anded with 3 is 3. This has the unintentional effect of making it unsafe to schedule ptabs / ptrel before a branch, or hoist it out of a loop. For example, __do_global_ctors, a part of libgcc that runs constructors at program startup, calls functions in a list which is delimited by -1. With the -mpt-fixed option, the ptabs will be done before testing against -1. That means that all the constructors will be run a bit quicker, but when the loop comes to the end of the list, the program crashes because ptabs loads -1 into a target register. Since this option is unsafe for any hardware implementing the current architecture specification, the default is -mno-pt-fixed. Unless the user specifies a specific cost with -mgettrcost, -mno-pt-fixed also implies -mgettrcost=100; this deters register allocation using target registers for storing ordinary integers.
-minvalid-symbols
Assume symbols might be invalid. Ordinary function symbols generated by the compiler will always be valid to load with movi/shori/ptabs or movi/shori/ptrel, but with assembler and/or linker tricks it is possible to generate symbols that will cause ptabs / ptrel to trap. This option is only meaningful when -mno-pt-fixed is in effect. It will then prevent cross-basic-block cse, hoisting and most scheduling of symbol loads. The default is -mno-invalid-symbols.
SPARC Options

These -m options are supported on the SPARC:
-mno-app-regs
-mapp-regs
Specify -mapp-regs to generate output using the global registers 2 through 4, which the SPARC SVR4 ABI reserves for applications. This is the default.
To be fully SVR4 ABI compliant at the cost of some performance loss, specify -mno-app-regs. You should compile libraries and system software with this option.

-mfpu
-mhard-float
Generate output containing floating point instructions. This is the default.
-mno-fpu
-msoft-float
Generate output containing library calls for floating point. Warning: the requisite libraries are not available for all SPARC targets. Normally the facilities of the machine's usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation. The embedded targets sparc-*-aout and sparclite-*-* do provide software floating point support.
-msoft-float changes the calling convention in the output file; therefore, it is only useful if you compile all of a program with this option. In particular, you need to compile libgcc.a, the library that comes with GCC , with -msoft-float in order for this to work.

-mhard-quad-float
Generate output containing quad-word (long double) floating point instructions.
-msoft-quad-float
Generate output containing library calls for quad-word (long double) floating point instructions. The functions called are those specified in the SPARC ABI . This is the default.
As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the -msoft-quad-float option is the default.

-mno-unaligned-doubles
-munaligned-doubles
Assume that doubles have 8 byte alignment. This is the default.
With -munaligned-doubles, GCC assumes that doubles have 8 byte alignment only if they are contained in another type, or if they have an absolute address. Otherwise, it assumes they have 4 byte alignment. Specifying this option avoids some rare compatibility problems with code generated by other compilers. It is not the default because it results in a performance loss, especially for floating point code.

-mno-faster-structs
-mfaster-structs
With -mfaster-structs, the compiler assumes that structures should have 8 byte alignment. This enables the use of pairs of "ldd" and "std" instructions for copies in structure assignment, in place of twice as many "ld" and "st" pairs. However, the use of this changed alignment directly violates the SPARC ABI . Thus, it's intended only for use on targets where the developer acknowledges that their resulting code will not be directly in line with the rules of the ABI .
-mimpure-text
-mimpure-text, used in addition to -shared, tells the compiler to not pass -z text to the linker when linking a shared object. Using this option, you can link position-dependent code into a shared object.
-mimpure-text suppresses the "relocations remain against allocatable but non-writable sections" linker error message. However, the necessary relocations will trigger copy-on-write, and the shared object is not actually shared across processes. Instead of using -mimpure-text, you should compile all source code with -fpic or -fPIC.

This option is only available on SunOS and Solaris.

-mcpu=cpu_type
Set the instruction set, register set, and instruction scheduling parameters for machine type cpu_type. Supported values for cpu_type are v7, cypress, v8, supersparc, sparclite, f930, f934, hypersparc, sparclite86x, sparclet, tsc701, v9, ultrasparc, ultrasparc3, niagara and niagara2.
Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are v7, v8, sparclite, sparclet, v9.

Here is a list of each supported architecture and their supported implementations.

v7:             cypress
v8:             supersparc, hypersparc
sparclite:      f930, f934, sparclite86x
sparclet:       tsc701
v9:             ultrasparc, ultrasparc3, niagara, niagara2
By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With -mcpu=cypress, the compiler additionally optimizes it for the Cypress CY7C602 chip, as used in the SPARCStation/SPARCServer 3xx series. This is also appropriate for the older SPARCStation 1, 2, IPX etc.
With -mcpu=v8, GCC generates code for the V8 variant of the SPARC architecture. The only difference from V7 code is that the compiler emits the integer multiply and integer divide instructions which exist in SPARC-V8 but not in SPARC-V7 . With -mcpu=supersparc, the compiler additionally optimizes it for the SuperSPARC chip, as used in the SPARCStation 10, 1000 and 2000 series.

With -mcpu=sparclite, GCC generates code for the SPARClite variant of the SPARC architecture. This adds the integer multiply, integer divide step and scan ("ffs") instructions which exist in SPARClite but not in SPARC-V7 . With -mcpu=f930, the compiler additionally optimizes it for the Fujitsu MB86930 chip, which is the original SPARClite, with no FPU . With -mcpu=f934, the compiler additionally optimizes it for the Fujitsu MB86934 chip, which is the more recent SPARClite with FPU .

With -mcpu=sparclet, GCC generates code for the SPARClet variant of the SPARC architecture. This adds the integer multiply, multiply/accumulate, integer divide step and scan ("ffs") instructions which exist in SPARClet but not in SPARC-V7 . With -mcpu=tsc701, the compiler additionally optimizes it for the TEMIC SPARClet chip.

With -mcpu=v9, GCC generates code for the V9 variant of the SPARC architecture. This adds 64-bit integer and floating-point move instructions, 3 additional floating-point condition code registers and conditional move instructions. With -mcpu=ultrasparc, the compiler additionally optimizes it for the Sun UltraSPARC I/II/IIi chips. With -mcpu=ultrasparc3, the compiler additionally optimizes it for the Sun UltraSPARC III/III+/IIIi/IIIi+/IV/IV+ chips. With -mcpu=niagara, the compiler additionally optimizes it for Sun UltraSPARC T1 chips. With -mcpu=niagara2, the compiler additionally optimizes it for Sun UltraSPARC T2 chips.

-mtune=cpu_type
Set the instruction scheduling parameters for machine type cpu_type, but do not set the instruction set or register set that the option -mcpu=cpu_type would.
The same values for -mcpu=cpu_type can be used for -mtune=cpu_type, but the only useful values are those that select a particular cpu implementation. Those are cypress, supersparc, hypersparc, f930, f934, sparclite86x, tsc701, ultrasparc, ultrasparc3, niagara, and niagara2.

-mv8plus
-mno-v8plus
With -mv8plus, GCC generates code for the SPARC-V8+ ABI . The difference from the V8 ABI is that the global and out registers are considered 64-bit wide. This is enabled by default on Solaris in 32-bit mode for all SPARC-V9 processors.
-mvis
-mno-vis
With -mvis, GCC generates code that takes advantage of the UltraSPARC Visual Instruction Set extensions. The default is -mno-vis.
These -m options are supported in addition to the above on SPARC-V9 processors in 64-bit environments:
-mlittle-endian
Generate code for a processor running in little-endian mode. It is only available for a few configurations and most notably not on Solaris and Linux.
-m32
-m64
Generate code for a 32-bit or 64-bit environment. The 32-bit environment sets int, long and pointer to 32 bits. The 64-bit environment sets int to 32 bits and long and pointer to 64 bits.
-mcmodel=medlow
Generate code for the Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.
-mcmodel=medmid
Generate code for the Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.
-mcmodel=medany
Generate code for the Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.
-mcmodel=embmedany
Generate code for the Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.
-mstack-bias
-mno-stack-bias
With -mstack-bias, GCC assumes that the stack pointer, and frame pointer if present, are offset by -2047 which must be added back when making stack frame references. This is the default in 64-bit mode. Otherwise, assume no such offset is present.
These switches are supported in addition to the above on Solaris:
-threads
Add support for multithreading using the Solaris threads library. This option sets flags for both the preprocessor and linker. This option does not affect the thread safety of object code produced by the compiler or that of libraries supplied with it.
-pthreads
Add support for multithreading using the POSIX threads library. This option sets flags for both the preprocessor and linker. This option does not affect the thread safety of object code produced by the compiler or that of libraries supplied with it.
-pthread
This is a synonym for -pthreads.
SPU Options

These -m options are supported on the SPU:
-mwarn-reloc
-merror-reloc
The loader for SPU does not handle dynamic relocations. By default, GCC will give an error when it generates code that requires a dynamic relocation. -mno-error-reloc disables the error, -mwarn-reloc will generate a warning instead.
-msafe-dma
-munsafe-dma
Instructions which initiate or test completion of DMA must not be reordered with respect to loads and stores of the memory which is being accessed. Users typically address this problem using the volatile keyword, but that can lead to inefficient code in places where the memory is known to not change. Rather than mark the memory as volatile we treat the DMA instructions as potentially effecting all memory. With -munsafe-dma users must use the volatile keyword to protect memory accesses.
-mbranch-hints
By default, GCC will generate a branch hint instruction to avoid pipeline stalls for always taken or probably taken branches. A hint will not be generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.
-msmall-mem
-mlarge-mem
By default, GCC generates code assuming that addresses are never larger than 18 bits. With -mlarge-mem code is generated that assumes a full 32 bit address.
-mstdmain
By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With -mstdmain, GCC will link your program against startup code that assumes a C99-style interface to "main", including a local copy of "argv" strings.
-mfixed-range=register-range
Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator can not use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma.
-mdual-nops
-mdual-nops=n
By default, GCC will insert nops to increase dual issue when it expects it to increase performance. n can be a value from 0 to 10. A smaller n will insert fewer nops. 10 is the default, 0 is the same as -mno-dual-nops. Disabled with -Os.
-mhint-max-nops=n
Maximum number of nops to insert for a branch hint. A branch hint must be at least 8 instructions away from the branch it is effecting. GCC will insert up to n nops to enforce this, otherwise it will not generate the branch hint.
-mhint-max-distance=n
The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is effecting. By default, GCC makes sure it is within 125.
-msafe-hints
Work around a hardware bug which causes the SPU to stall indefinitely. By default, GCC will insert the "hbrp" instruction to make sure this stall won't happen.
Options for System V

These additional options are available on System V Release 4 for compatibility with other compilers on those systems:
-G
Create a shared object. It is recommended that -symbolic or -shared be used instead.

-Qy

Identify the versions of each tool used by the compiler, in a ".ident" assembler directive in the output.

-Qn

Refrain from adding ".ident" directives to the output file (this is the default).

-YP,dirs
Search the directories dirs, and no others, for libraries specified with -l.
-Ym,dir
Look in the directory dir to find the M4 preprocessor. The assembler uses this option.
V850 Options

These -m options are defined for V850 implementations:
-mlong-calls
-mno-long-calls
Treat all calls as being far away (near). If calls are assumed to be far away, the compiler will always load the functions address up into a register, and call indirect through the pointer.
-mno-ep
-mep
Do not optimize (do optimize) basic blocks that use the same index pointer 4 or more times to copy pointer into the "ep" register, and use the shorter "sld" and "sst" instructions. The -mep option is on by default if you optimize.
-mno-prolog-function
-mprolog-function
Do not use (do use) external functions to save and restore registers at the prologue and epilogue of a function. The external functions are slower, but use less code space if more than one function saves the same number of registers. The -mprolog-function option is on by default if you optimize.
-mspace
Try to make the code as small as possible. At present, this just turns on the -mep and -mprolog-function options.
-mtda=n
Put static or global variables whose size is n bytes or less into the tiny data area that register "ep" points to. The tiny data area can hold up to 256 bytes in total (128 bytes for byte references).
-msda=n
Put static or global variables whose size is n bytes or less into the small data area that register "gp" points to. The small data area can hold up to 64 kilobytes.
-mzda=n
Put static or global variables whose size is n bytes or less into the first 32 kilobytes of memory.
-mv850
Specify that the target processor is the V850.
-mbig-switch
Generate code suitable for big switch tables. Use this option only if the assembler/linker complain about out of range branches within a switch table.
-mapp-regs
This option will cause r2 and r5 to be used in the code generated by the compiler. This setting is the default.
-mno-app-regs
This option will cause r2 and r5 to be treated as fixed registers.
-mv850e1
Specify that the target processor is the V850E1. The preprocessor constants __v850e1__ and __v850e__ will be defined if this option is used.
-mv850e
Specify that the target processor is the V850E. The preprocessor constant __v850e__ will be defined if this option is used.
If neither -mv850 nor -mv850e nor -mv850e1 are defined then a default target processor will be chosen and the relevant __v850*__ preprocessor constant will be defined.

The preprocessor constants __v850 and __v851__ are always defined, regardless of which processor variant is the target.

-mdisable-callt
This option will suppress generation of the CALLT instruction for the v850e and v850e1 flavors of the v850 architecture. The default is -mno-disable-callt which allows the CALLT instruction to be used.
VAX Options

These -m options are defined for the VAX:
-munix
Do not output certain jump instructions ("aobleq" and so on) that the Unix assembler for the VAX cannot handle across long ranges.
-mgnu
Do output those jump instructions, on the assumption that you will assemble with the GNU assembler.
-mg
Output code for g-format floating point numbers instead of d-format.

VxWorks Options

The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.
-mrtp
GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro "__RTP__".
-non-static
Link an RTP executable against shared libraries rather than static libraries. The options -static and -shared can also be used for RTPs; -static is the default.
-Bstatic
-Bdynamic
These options are passed down to the linker. They are defined for compatibility with Diab.
-Xbind-lazy
Enable lazy binding of function calls. This option is equivalent to -Wl,-z,now and is defined for compatibility with Diab.
-Xbind-now
Disable lazy binding of function calls. This option is the default and is defined for compatibility with Diab.
x86-64 Options

These are listed under
Xstormy16 Options

These options are defined for Xstormy16:
-msim
Choose startup files and linker script suitable for the simulator.
Xtensa Options

These options are supported for Xtensa targets:
-mconst16
-mno-const16
Enable or disable use of "CONST16" instructions for loading constant values. The "CONST16" instruction is currently not a standard option from Tensilica. When enabled, "CONST16" instructions are always used in place of the standard "L32R" instructions. The use of "CONST16" is enabled by default only if the "L32R" instruction is not available.
-mfused-madd
-mno-fused-madd
Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with more bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler's ability to combine multiply and add/subtract operations.
-mserialize-volatile
-mno-serialize-volatile
When this option is enabled, GCC inserts "MEMW" instructions before "volatile" memory references to guarantee sequential consistency. The default is -mserialize-volatile. Use -mno-serialize-volatile to omit the "MEMW" instructions.
-mtext-section-literals
-mno-text-section-literals
Control the treatment of literal pools. The default is -mno-text-section-literals, which places literals in a separate section in the output file. This allows the literal pool to be placed in a data RAM/ROM , and it also allows the linker to combine literal pools from separate object files to remove redundant literals and improve code size. With -mtext-section-literals, the literals are interspersed in the text section in order to keep them as close as possible to their references. This may be necessary for large assembly files.
-mtarget-align
-mno-target-align
When this option is enabled, GCC instructs the assembler to automatically align instructions to reduce branch penalties at the expense of some code density. The assembler attempts to widen density instructions to align branch targets and the instructions following call instructions. If there are not enough preceding safe density instructions to align a target, no widening will be performed. The default is -mtarget-align. These options do not affect the treatment of auto-aligned instructions like "LOOP", which the assembler will always align, either by widening density instructions or by inserting no-op instructions.
-mlongcalls
-mno-longcalls
When this option is enabled, GCC instructs the assembler to translate direct calls to indirect calls unless it can determine that the target of a direct call is in the range allowed by the call instruction. This translation typically occurs for calls to functions in other source files. Specifically, the assembler translates a direct "CALL" instruction into an "L32R" followed by a "CALLX" instruction. The default is -mno-longcalls. This option should be used in programs where the call target can potentially be out of range. This option is implemented in the assembler, not the compiler, so the assembly code generated by GCC will still show direct call instructions---look at the disassembled object code to see the actual instructions. Note that the assembler will use an indirect call for every cross-file call, not just those that really will be out of range.
zSeries Options

These are listed under
Options for Code Generation Conventions

These machine-independent options control the interface conventions used in code generation.
Most of them have both positive and negative forms; the negative form of -ffoo would be -fno-foo. In the table below, only one of the forms is listed---the one which is not the default. You can figure out the other form by either removing no- or adding it.

-fbounds-check
For front-ends that support it, generate additional code to check that indices used to access arrays are within the declared range. This is currently only supported by the Java and Fortran front-ends, where this option defaults to true and false respectively.
-ftrapv
This option generates traps for signed overflow on addition, subtraction, multiplication operations.
-fwrapv
This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. This option is enabled by default for the Java front-end, as required by the Java language specification.
-fexceptions
Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C ++ which normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C ++ . You may also wish to disable this option if you are compiling older C ++ programs that don't use exception handling.
-fnon-call-exceptions
Generate code that allows trapping instructions to throw exceptions. Note that this requires platform-specific runtime support that does not exist everywhere. Moreover, it only allows trapping instructions to throw exceptions, i.e. memory references or floating point instructions. It does not allow exceptions to be thrown from arbitrary signal handlers such as "SIGALRM".
-funwind-tables
Similar to -fexceptions, except that it will just generate any needed static data, but will not affect the generated code in any other way. You will normally not enable this option; instead, a language processor that needs this handling would enable it on your behalf.
-fasynchronous-unwind-tables
Generate unwind table in dwarf2 format, if supported by target machine. The table is exact at each instruction boundary, so it can be used for stack unwinding from asynchronous events (such as debugger or garbage collector).
-fpcc-struct-return
Return "short" "struct" and "union" values in memory like longer ones, rather than in registers. This convention is less efficient, but it has the advantage of allowing intercallability between GCC-compiled files and files compiled with other compilers, particularly the Portable C Compiler (pcc).
The precise convention for returning structures in memory depends on the target configuration macros.

Short structures and unions are those whose size and alignment match that of some integer type.

Warning: code compiled with the -fpcc-struct-return switch is not binary compatible with code compiled with the -freg-struct-return switch. Use it to conform to a non-default application binary interface.

-freg-struct-return
Return "struct" and "union" values in registers when possible. This is more efficient for small structures than -fpcc-struct-return.
If you specify neither -fpcc-struct-return nor -freg-struct-return, GCC defaults to whichever convention is standard for the target. If there is no standard convention, GCC defaults to -fpcc-struct-return, except on targets where GCC is the principal compiler. In those cases, we can choose the standard, and we chose the more efficient register return alternative.

Warning: code compiled with the -freg-struct-return switch is not binary compatible with code compiled with the -fpcc-struct-return switch. Use it to conform to a non-default application binary interface.

-fshort-enums
Allocate to an "enum" type only as many bytes as it needs for the declared range of possible values. Specifically, the "enum" type will be equivalent to the smallest integer type which has enough room.
Warning: the -fshort-enums switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.

-fshort-double
Use the same size for "double" as for "float".
Warning: the -fshort-double switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.

-fshort-wchar
Override the underlying type for wchar_t to be short unsigned int instead of the default for the target. This option is useful for building programs to run under WINE .
Warning: the -fshort-wchar switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.

-fno-common
In C code, controls the placement of uninitialized global variables. Unix C compilers have traditionally permitted multiple definitions of such variables in different compilation units by placing the variables in a common block. This is the behavior specified by -fcommon, and is the default for GCC on most targets. On the other hand, this behavior is not required by ISO C, and on some targets may carry a speed or code size penalty on variable references. The -fno-common option specifies that the compiler should place uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without "extern") in two different compilations, you will get a multiple-definition error when you link them. In this case, you must compile with -fcommon instead. Compiling with -fno-common is useful on targets for which it provides better performance, or if you wish to verify that the program will work on other systems which always treat uninitialized variable declarations this way.
-fno-ident
Ignore the #ident directive.
-finhibit-size-directive
Don't output a ".size" assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling crtstuff.c; you should not need to use it for anything else.
-fverbose-asm
Put extra commentary information in the generated assembly code to make it more readable. This option is generally only of use to those who actually need to read the generated assembly code (perhaps while debugging the compiler itself).
-fno-verbose-asm, the default, causes the extra information to be omitted and is useful when comparing two assembler files.

-frecord-gcc-switches
This switch causes the command line that was used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the -fverbose-asm switch, but that switch only records information in the assembler output file as comments, so it never reaches the object file.
-fpic
Generate position-independent code ( PIC ) suitable for use in a shared library, if supported for the target machine. Such code accesses all constant addresses through a global offset table ( GOT ). The dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of GCC ; it is part of the operating system). If the GOT size for the linked executable exceeds a machine-specific maximum size, you get an error message from the linker indicating that -fpic does not work; in that case, recompile with -fPIC instead. (These maximums are 8k on the SPARC and 32k on the m68k and RS/6000 . The 386 has no such limit.)
Position-independent code requires special support, and therefore works only on certain machines. For the 386, GCC supports PIC for System V but not for the Sun 386i. Code generated for the IBM RS/6000 is always position-independent.

When this flag is set, the macros "__pic__" and "__PIC__" are defined to 1.

-fPIC
If supported for the target machine, emit position-independent code, suitable for dynamic linking and avoiding any limit on the size of the global offset table. This option makes a difference on the m68k, PowerPC and SPARC .
Position-independent code requires special support, and therefore works only on certain machines.

When this flag is set, the macros "__pic__" and "__PIC__" are defined to 2.

-fpie
-fPIE
These options are similar to -fpic and -fPIC, but generated position independent code can be only linked into executables. Usually these options are used when -pie GCC option will be used during linking.
-fpie and -fPIE both define the macros "__pie__" and "__PIE__". The macros have the value 1 for -fpie and 2 for -fPIE.

-fno-jump-tables
Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies. This option is of use in conjunction with -fpic or -fPIC for building code which forms part of a dynamic linker and cannot reference the address of a jump table. On some targets, jump tables do not require a GOT and this option is not needed.
-ffixed-reg
Treat the register named reg as a fixed register; generated code should never refer to it (except perhaps as a stack pointer, frame pointer or in some other fixed role).
reg must be the name of a register. The register names accepted are machine-specific and are defined in the "REGISTER_NAMES" macro in the machine description macro file.

This flag does not have a negative form, because it specifies a three-way choice.

-fcall-used-reg
Treat the register named reg as an allocable register that is clobbered by function calls. It may be allocated for temporaries or variables that do not live across a call. Functions compiled this way will not save and restore the register reg.
It is an error to used this flag with the frame pointer or stack pointer. Use of this flag for other registers that have fixed pervasive roles in the machine's execution model will produce disastrous results.

This flag does not have a negative form, because it specifies a three-way choice.

-fcall-saved-reg
Treat the register named reg as an allocable register saved by functions. It may be allocated even for temporaries or variables that live across a call. Functions compiled this way will save and restore the register reg if they use it.
It is an error to used this flag with the frame pointer or stack pointer. Use of this flag for other registers that have fixed pervasive roles in the machine's execution model will produce disastrous results.

A different sort of disaster will result from the use of this flag for a register in which function values may be returned.

This flag does not have a negative form, because it specifies a three-way choice.

-fpack-struct[=n]
Without a value specified, pack all structure members together without holes. When a value is specified (which must be a small power of two), pack structure members according to this value, representing the maximum alignment (that is, objects with default alignment requirements larger than this will be output potentially unaligned at the next fitting location.
Warning: the -fpack-struct switch causes GCC to generate code that is not binary compatible with code generated without that switch. Additionally, it makes the code suboptimal. Use it to conform to a non-default application binary interface.

-finstrument-functions
Generate instrumentation calls for entry and exit to functions. Just after function entry and just before function exit, the following profiling functions will be called with the address of the current function and its call site. (On some platforms, "__builtin_return_address" does not work beyond the current function, so the call site information may not be available to the profiling functions otherwise.)
void __cyg_profile_func_enter (void *this_fn,
                               void *call_site);
void __cyg_profile_func_exit  (void *this_fn,
                               void *call_site);
The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.
This instrumentation is also done for functions expanded inline in other functions. The profiling calls will indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use extern inline in your C code, an addressable version of such functions must be provided. (This is normally the case anyways, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)

A function may be given the attribute "no_instrument_function", in which case this instrumentation will not be done. This can be used, for example, for the profiling functions listed above, high-priority interrupt routines, and any functions from which the profiling functions cannot safely be called (perhaps signal handlers, if the profiling routines generate output or allocate memory).

-finstrument-functions-exclude-file-list=file,file,...
Set the list of functions that are excluded from instrumentation (see the description of "-finstrument-functions"). If the file that contains a function definition matches with one of file, then that function is not instrumented. The match is done on substrings: if the file parameter is a substring of the file name, it is considered to be a match.
For example, "-finstrument-functions-exclude-file-list=/bits/stl,include/sys" will exclude any inline function defined in files whose pathnames contain "/bits/stl" or "include/sys".

If, for some reason, you want to include letter ',' in one of sym, write ','. For example, "-finstrument-functions-exclude-file-list=',,tmp'" (note the single quote surrounding the option).

-finstrument-functions-exclude-function-list=sym,sym,...
This is similar to "-finstrument-functions-exclude-file-list", but this option sets the list of function names to be excluded from instrumentation. The function name to be matched is its user-visible name, such as "vector<int> blah(const vector<int> &)", not the internal mangled name (e.g., "_Z4blahRSt6vectorIiSaIiEE"). The match is done on substrings: if the sym parameter is a substring of the function name, it is considered to be a match.
-fstack-check
Generate code to verify that you do not go beyond the boundary of the stack. You should specify this flag if you are running in an environment with multiple threads, but only rarely need to specify it in a single-threaded environment since stack overflow is automatically detected on nearly all systems if there is only one stack.
Note that this switch does not actually cause checking to be done; the operating system or the language runtime must do that. The switch causes generation of code to ensure that they see the stack being extended.

You can additionally specify a string parameter: "no" means no checking, "generic" means force the use of old-style checking, "specific" means use the best checking method and is equivalent to bare -fstack-check.

Old-style checking is a generic mechanism that requires no specific target support in the compiler but comes with the following drawbacks:

1.
Modified allocation strategy for large objects: they will always be allocated dynamically if their size exceeds a fixed threshold.

2.

Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.

3.

Inefficiency: because of both the modified allocation strategy and the generic implementation, the performances of the code are hampered.

Note that old-style stack checking is also the fallback method for "specific" if no target support has been added in the compiler.
-fstack-limit-register=reg
-fstack-limit-symbol=sym
-fno-stack-limit
Generate code to ensure that the stack does not grow beyond a certain value, either the value of a register or the address of a symbol. If the stack would grow beyond the value, a signal is raised. For most targets, the signal is raised before the stack overruns the boundary, so it is possible to catch the signal without taking special precautions.
For instance, if the stack starts at absolute address 0x80000000 and grows downwards, you can use the flags -fstack-limit-symbol=__stack_limit and -Wl,--defsym,__stack_limit=0x7ffe0000 to enforce a stack limit of 128KB. Note that this may only work with the GNU linker.

-fargument-alias
-fargument-noalias
-fargument-noalias-global
-fargument-noalias-anything
Specify the possible relationships among parameters and between parameters and global data.
-fargument-alias specifies that arguments (parameters) may alias each other and may alias global storage.-fargument-noalias specifies that arguments do not alias each other, but may alias global storage.-fargument-noalias-global specifies that arguments do not alias each other and do not alias global storage. -fargument-noalias-anything specifies that arguments do not alias any other storage.

Each language will automatically use whatever option is required by the language standard. You should not need to use these options yourself.

-fleading-underscore
This option and its counterpart, -fno-leading-underscore, forcibly change the way C symbols are represented in the object file. One use is to help link with legacy assembly code.
Warning: the -fleading-underscore switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface. Not all targets provide complete support for this switch.

-ftls-model=model
Alter the thread-local storage model to be used. The model argument should be one of "global-dynamic", "local-dynamic", "initial-exec" or "local-exec".
The default without -fpic is "initial-exec"; with -fpic the default is "global-dynamic".

-fvisibility=default|internal|hidden|protected
Set the default ELF image symbol visibility to the specified option---all symbols will be marked with this unless overridden within the code. Using this feature can very substantially improve linking and load times of shared object libraries, produce more optimized code, provide near-perfect API export and prevent symbol clashes. It is strongly recommended that you use this in any shared objects you distribute.
Despite the nomenclature, "default" always means public ie; available to be linked against from outside the shared object. "protected" and "internal" are pretty useless in real-world usage so the only other commonly used option will be "hidden". The default if -fvisibility isn't specified is "default", i.e., make every symbol public---this causes the same behavior as previous versions of GCC .

A good explanation of the benefits offered by ensuring ELF symbols have the correct visibility is given by "How To Write Shared Libraries" by Ulrich Drepper (which can be found at <http://people.redhat.com/~drepper/>)---however a superior solution made possible by this option to marking things hidden when the default is public is to make the default hidden and mark things public. This is the norm with DLL 's on Windows and with -fvisibility=hidden and "__attribute__ ((visibility("default")))" instead of "__declspec(dllexport)" you get almost identical semantics with identical syntax. This is a great boon to those working with cross-platform projects.

For those adding visibility support to existing code, you may find #pragma GCC visibility of use. This works by you enclosing the declarations you wish to set visibility for with (for example) #pragma GCC visibility push(hidden) and #pragma GCC visibility pop. Bear in mind that symbol visibility should be viewed as part of the API interface contract and thus all new code should always specify visibility when it is not the default ie; declarations only for use within the local DSO should always be marked explicitly as hidden as so to avoid PLT indirection overheads---making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C ++ specification requirements, operator new and operator delete must always be of default visibility.

Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say #pragma GCC visibility push(default) before including any such headers.

extern declarations are not affected by -fvisibility, so a lot of code can be recompiled with -fvisibility=hidden with no modifications. However, this means that calls to extern functions with no explicit visibility will use the PLT , so it is more effective to use __attribute ((visibility)) and/or #pragma GCC visibility to tell the compiler which extern declarations should be treated as hidden.

Note that -fvisibility does affect C ++ vague linkage entities. This means that, for instance, an exception class that will be thrown between DSOs must be explicitly marked with default visibility so that the type_info nodes will be unified between the DSOs.

An overview of these techniques, their benefits and how to use them is at <http://gcc.gnu.org/wiki/Visibility>.

Environment
This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.

Note that you can also specify places to search using options such as -B, -I and -L. These take precedence over places specified using environment variables, which in turn take precedence over those specified by the configuration of GCC .

LANG
LC_CTYPE
LC_MESSAGES
LC_ALL
These environment variables control the way that GCC uses localization information that allow GCC to work with different national conventions. GCC inspects the locale categories LC_CTYPE and LC_MESSAGES if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is en_GB.UTF-8 for English in the United Kingdom encoded in UTF-8 .
The LC_CTYPE environment variable specifies character classification. GCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that would otherwise be interpreted as a string end or escape.

The LC_MESSAGES environment variable specifies the language to use in diagnostic messages.

If the LC_ALL environment variable is set, it overrides the value of LC_CTYPE and LC_MESSAGES ; otherwise, LC_CTYPE and LC_MESSAGES default to the value of the LANG environment variable. If none of these variables are set, GCC defaults to traditional C English behavior.

TMPDIR
If TMPDIR is set, it specifies the directory to use for temporary files. GCC uses temporary files to hold the output of one stage of compilation which is to be used as input to the next stage: for example, the output of the preprocessor, which is the input to the compiler proper.
GCC_EXEC_PREFIX
If GCC_EXEC_PREFIX is set, it specifies a prefix to use in the names of the subprograms executed by the compiler. No slash is added when this prefix is combined with the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.
If GCC_EXEC_PREFIX is not set, GCC will attempt to figure out an appropriate prefix to use based on the pathname it was invoked with.

If GCC cannot find the subprogram using the specified prefix, it tries looking in the usual places for the subprogram.

The default value of GCC_EXEC_PREFIX is prefix/lib/gcc/ where prefix is the prefix to the installed compiler. In many cases prefix is the value of "prefix" when you ran the configure script.

Other prefixes specified with -B take precedence over this prefix.

This prefix is also used for finding files such as crt0.o that are used for linking.

In addition, the prefix is used in an unusual way in finding the directories to search for header files. For each of the standard directories whose name normally begins with /usr/local/lib/gcc (more precisely, with the value of GCC_INCLUDE_DIR ), GCC tries replacing that beginning with the specified prefix to produce an alternate directory name. Thus, with -Bfoo/, GCC will search foo/bar where it would normally search /usr/local/lib/bar. These alternate directories are searched first; the standard directories come next. If a standard directory begins with the configured prefix then the value of prefix is replaced by GCC_EXEC_PREFIX when looking for header files.

COMPILER_PATH
The value of COMPILER_PATH is a colon-separated list of directories, much like PATH . GCC tries the directories thus specified when searching for subprograms, if it can't find the subprograms using GCC_EXEC_PREFIX .
LIBRARY_PATH
The value of LIBRARY_PATH is a colon-separated list of directories, much like PATH . When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it can't find them using GCC_EXEC_PREFIX . Linking using GCC also uses these directories when searching for ordinary libraries for the -l option (but directories specified with -L come first).
LANG
This variable is used to pass locale information to the compiler. One way in which this information is used is to determine the character set to be used when character literals, string literals and comments are parsed in C and C ++ . When the compiler is configured to allow multibyte characters, the following values for LANG are recognized:
C-JIS
Recognize JIS characters.
C-SJIS
Recognize SJIS characters.
C-EUCJP
Recognize EUCJP characters.
If LANG is not defined, or if it has some other value, then the compiler will use mblen and mbtowc as defined by the default locale to recognize and translate multibyte characters.
Some additional environments variables affect the behavior of the preprocessor.
CPATH
C_INCLUDE_PATH
CPLUS_INCLUDE_PATH
OBJC_INCLUDE_PATH
Each variable's value is a list of directories separated by a special character, much like PATH , in which to look for header files. The special character, "PATH_SEPARATOR", is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.
CPATH specifies a list of directories to be searched as if specified with -I, but after any paths given with -I options on the command line. This environment variable is used regardless of which language is being preprocessed.

The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with -isystem, but after any paths given with -isystem options on the command line.

In all these variables, an empty element instructs the compiler to search its current working directory. Empty elements can appear at the beginning or end of a path. For instance, if the value of CPATH is ":/special/include", that has the same effect as -I. -I/special/include.

DEPENDENCIES_OUTPUT
If this variable is set, its value specifies how to output dependencies for Make based on the non-system header files processed by the compiler. System header files are ignored in the dependency output.
The value of DEPENDENCIES_OUTPUT can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form file target, in which case the rules are written to file file using target as the target name.

In other words, this environment variable is equivalent to combining the options -MM and -MF, with an optional -MT switch too.

SUNPRO_DEPENDENCIES
This variable is the same as DEPENDENCIES_OUTPUT (see above), except that system header files are not ignored, so it implies -M rather than -MM. However, the dependence on the main input file is omitted.
